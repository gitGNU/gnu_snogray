-- swig.lua -- Functions for interacting with SWIG
--
--  Copyright (C) 2012  Miles Bader <miles@gnu.org>
--
-- This source code is free software; you can redistribute it and/or
-- modify it under the terms of the GNU General Public License as
-- published by the Free Software Foundation; either version 3, or (at
-- your option) any later version.  See the file COPYING for more details.
--
-- Written by Miles Bader <miles@gnu.org>
--

-- module
--
local swig = {}


-- imports
--
local raw = require 'snogray.snograw'


----------------------------------------------------------------
-- A facility for adding hooks into the SWIG metatable for an object
--

-- Return a table attached to OBJ (a userdata object or table), which
-- is used as to satisfy __index queries on OBJ.  If such a table
-- already exists for OBJ, it is returned, otherwise a new one is
-- added and returned.  The added table is consulted before any
-- previously existing __index hook, and the previous hook called only
-- when a request is not found in the wrapper table.
--
function swig.index_wrappers (obj)
   local mt = getmetatable (obj)

   if not mt.__raw_index then
      mt.__raw_index = mt.__index

      -- Note that we can't just make the old __index function an
      -- __index for our new __index table, because the first argument
      -- passed to it would be the wrong thing (the metatable, not the
      -- underlying object).
      --
      mt.__index =
	 function (obj, key)
	    local mt = getmetatable (obj)
	    local rawi = mt.__raw_index
	    local wraps = mt.__index_wrappers
	    return (wraps and wraps[key]) or rawi (obj, key)
	 end
      mt.__index_wrappers = {}
   end

   return mt.__index_wrappers
end

function swig.has_index_wrappers (obj)
   return getmetatable(obj).__index_wrappers
end

-- Lookup KEY in the wrapped object OBJ without invoking any wrapper.
--
function swig.nowrap_index (obj, key)
   return getmetatable (obj).__raw_index (obj, key)
end

-- Call method METH in the wrapped object OBJ without invoking any wrapper.
--
function swig.nowrap_meth_call (obj, meth, ...)
   return getmetatable (obj).__raw_index (obj, meth) (obj, ...)
end


----------------------------------------------------------------
-- SWIG type handling
--

-- Type name stripping for old-style mangled SWIG type names.
--
local function strip_old_swig_type (name)
   name = name:gsub (" const","")
   name = name:gsub (" ","")
   name = name:gsub ("_p_", "")
   name = name:gsub ("snogray__", "")
   name = name:gsub ("^RefT(.*)_t$", "%1")

   -- This is not reliable, because we can't really distinguish a "T"
   -- meaning "<" from a "T" which is part of a type name, but it
   -- should wort for the particular type names we use, because none
   -- of the types we use inside brackets (in templates) contain a
   -- real "T".
   --
   name = name:gsub ("T([^T]*)_t$", "<%1>")

   return name
end

-- Return the type name NAME with all extraneous junk removed.  
local function strip_swig_type (name)
   -- If the first character is an underscore, assume it's an old-style
   -- mangled SWIG type name.
   --
   if name:byte() == 95 then -- 95 is '_'
      return strip_old_swig_type (name)
   end

   name = name:gsub ("snogray::","")
   name = name:gsub (" const","")
   name = name:gsub (" ","")
   name = name:gsub ("[*]*$","")
   name = name:gsub ("^Ref<(.*)>$", "%1")

   return name
end

-- A table mapping raw SWIG type names to our desired "pretty" type
-- name.  Mostly these are automatically generated by massaging the
-- SWIG type names, but we also prime the table with some entries to
-- get around differences in various SWIG versions.
--
local swig_type_names = { ["TXform<float>"] = "Xform" }

-- An extension of the standard "type" function that also handle SWIG
-- types nicely (which to normal Lua are all just "userdata").
--
-- These names are not arbitrary and are used by other code to
-- identify the types of objects.  In general, for SWIG objects, the
-- type name should be the sames as the root C++ type name, with
-- modifiers such as const/volatile/*/& (etc) removed.
--
function swig.type (obj)
   local type = swig_type (obj) or type (obj)
   local best = swig_type_names[type]

   -- If we don't have entry for TYPE, then make one.
   --
   if not best then
      --
      -- Process the raw SWIG type names, proces to of extraneous
      -- junk, and keep the shortest one (as that's likely to be the
      -- most concise).  In particular, this process usually prefers
      -- typedefs to the type they alias.
      --
      for comp in type:gmatch ("[^|]+") do
	 comp = strip_swig_type (comp)
	 if not best or #comp < #best then
	    best = comp
	 end
      end

      -- See if there's an overriding entry for our automatic result
      -- BEST (mostly this is used to add desirable typedefs, as
      -- different SWIG versions are not consistent about keeping
      -- track of typedefs).
      --
      best = swig_type_names[best] or best

      -- Add a mapping for TYPE => BEST so we don't have to do all
      -- this next time.
      --
      swig_type_names[type] = best
   end

   return best
end


-- return the module
--
return swig
